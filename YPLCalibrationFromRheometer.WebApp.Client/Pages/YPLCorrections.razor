@page "/YPLCorrections"
@inject ILogger<YPLCorrections> logger

<UnitAndReferenceChoiceTag HttpHost="@YPLCalibrationFromRheometer.WebApp.Client.Configuration.YPLCalibrationHostURL"
                           HttpBasePath="YPLCalibrationFromRheometer/api/"
                           HttpController="DrillingUnitChoiceSets">
    <h1>YPLCorrections</h1>
    <div hidden="@IsHidSubPanel">
        <div>
            <table class="table">
                <thead>
                    <tr>
                        <td>Name</td>
                        <td>Description</td>
                        <td></td>
                    </tr>
                </thead>
                <tbody>
                    @if (IsHidInputAdd)
                    {
                        <tr>
                            <td>
                                <span class="label">@(yplCorrectionList[yplCorrectionIdx].Name)</span>
                            </td>
                            <td>
                                <span class="label">@(yplCorrectionList[yplCorrectionIdx].Description)</span>
                            </td>
                            <td></td>
                        </tr>
                    }
                    else
                    {
                        <tr>
                            <td>
                                <input class="text" type="text" size="50" @bind="@updatedYplCorrectionName" />
                            </td>
                            <td>
                                <input class="text" type="text" size="50" @bind="@updatedYplCorrectionDescr" />
                            </td>
                            <td align="right">
                                <button class="btn btn-primary" @onclick="@(() => Update(yplCorrectionIdx))">Update</button>
                                <button class="btn btn-primary" @onclick="@(() => Cancel(yplCorrectionIdx))">Cancel</button>
                            </td>
                        </tr>
                    }
                </tbody>
                <tfoot>
                </tfoot>
            </table>
        </div>
    </div>

    @if (yplCorrectionList == null)
    {
        <p><em>Loading...</em></p>
    }
    else
    {
        <div hidden="@IsHidMainPanel">
            <table class="table">
                <thead>
                    <tr>
                        <td>Name</td>
                        <td>Description</td>
                        <td></td>
                    </tr>
                </thead>
                <tbody>
                    @for (int i = 0; i < yplCorrectionList.Count; i++)
                    {
                        var local_i = i; // Do not use a loop variable directly in a lambda expression
                        <tr>
                            <td>
                                <span class="label">@yplCorrectionList[i].Name</span>
                            </td>
                            <td>
                                <span class="label">@yplCorrectionList[i].Description</span>
                            </td>
                            <td align="right">
                                <button class="btn btn-primary" @onclick="@(() => Edit(local_i))">Edit</button>
                                <button class="btn btn-primary" @onclick="@(() => Delete(local_i))">Delete</button>
                            </td>
                        </tr>
                    }
                </tbody>
                <tfoot>
                    <tr>
                        <td>
                            <input class="text" type="text" size="50" @bind="@addedYplCorrectionName" />
                        </td>
                        <td>
                            <input class="text" type="text" size="50" @bind="@addedYplCorrectionDescr" />
                        </td>
                        <td align="right">
                            <button class="btn btn-primary" @onclick="@(() => Add())">Add</button>
                            <button class="btn btn-primary" @onclick="@(() => Cancel())">Cancel</button>
                        </td>
                    </tr>
                </tfoot>
            </table>
        </div>
        @if (yplCorrectionIdx >= 0)
        {
            ICollection<RheometerMeasurement> inputList = yplCorrectionList[yplCorrectionIdx].RheogramInput.Measurements;
            ICollection<ShearRateAndStress> fullyCorrectedList = yplCorrectionList[yplCorrectionIdx].RheogramFullyCorrected;
            ICollection<ShearRateAndStress> shearRateCorrectedList = yplCorrectionList[yplCorrectionIdx].RheogramShearRateCorrected;
            ICollection<ShearRateAndStress> shearStressCorrectedList = yplCorrectionList[yplCorrectionIdx].RheogramShearStressCorrected;
            <div hidden="@IsHidSubPanel">
                <div>
                    <button class="btn btn-link" @onclick="@(() => HideInput())"><h2>Input Rheogram</h2></button>
                    <div hidden="@IsHidInputPanel">
                        <table class="table">
                            <thead></thead>
                            <tbody>
                                <tr>
                                    <td>
                                        <select @bind="@rheogramID">
                                            @foreach (Rheogram baseData1 in inputRheogramList)
                                            {
                                                <option value="@baseData1.ID">@baseData1.Name</option>
                                            }
                                        </select>
                                    </td>
                                    <td align="right">
                                        <button class="btn btn-primary" @onclick="@(() => UpdateInput())">Update</button>
                                    </td>
                                </tr>
                            </tbody>
                            <tfoot></tfoot>
                        </table>
                        <p>Warning, any change made to this Rheogram will be sent to the database and thus will affect other YPLCorrections which refer to it</p>
                        <InputRheogram HTTPClient="@APIUtils.HttpClientYPLCalibrationFromRheometer" IsHidden="@IsHidInputAdd" Rheogram="@yplCorrectionList[yplCorrectionIdx].RheogramInput" RheogramID="@rheogramID" />
                        <h3 hidden="@IsHidInputPanel">YPLModel (based on Mullineux)</h3>
                        <YPLCalibrationTable YPLModel="@yplCorrectionList[yplCorrectionIdx].YPLModelBasedOnNewtonianInputs" IsHidden="@IsHidInputPanel" />
                    </div>
                </div>
                <div>
                    <button class="btn btn-link" @onclick="@(() => HideCalc())"><h2>Fully corrected Rheogram</h2></button>
                    <DisplayRheogram ShearRateAndStresses="@yplCorrectionList[yplCorrectionIdx].RheogramFullyCorrected" IsHidden="@IsHidCalcPanel" />
                    <h3 hidden="@IsHidCalcPanel">YPLModel (based on Mullineux)</h3>
                    <YPLCalibrationTable YPLModel="@yplCorrectionList[yplCorrectionIdx].YPLModelFullyCorrected" IsHidden="@IsHidCalcPanel" />
                </div>
                <div>
                    <button class="btn btn-link" @onclick="@(() => HideCalc())"><h2>ShearRate corrected Rheogram</h2></button>
                    <DisplayRheogram ShearRateAndStresses="@yplCorrectionList[yplCorrectionIdx].RheogramShearRateCorrected" IsHidden="@IsHidCalcPanel" />
                    <h3 hidden="@IsHidCalcPanel">YPLModel (based on Mullineux)</h3>
                    <YPLCalibrationTable YPLModel="@yplCorrectionList[yplCorrectionIdx].YPLModelShearRateCorrected" IsHidden="@IsHidCalcPanel" />
                </div>
                <div>
                    <button class="btn btn-link" @onclick="@(() => HideCalc())"><h2>ShearStress corrected Rheogram</h2></button>
                    <DisplayRheogram ShearRateAndStresses="@yplCorrectionList[yplCorrectionIdx].RheogramShearStressCorrected" IsHidden="@IsHidCalcPanel" />
                    <h3 hidden="@IsHidCalcPanel">YPLModel (based on Mullineux)</h3>
                    <YPLCalibrationTable YPLModel="@yplCorrectionList[yplCorrectionIdx].YPLModelShearStressCorrected" IsHidden="@IsHidCalcPanel" />
                </div>
                <div hidden="@IsHidCalcPanel">
                    <ScatterPlot XQuantityName="FluidShearRate" YQuantityName="FluidShearStress"
                         XValues="@shearRates" YValues="@shearStresses" UseMarker="true" Name="Rheogram"
                         ListXValues="@listShearRates" ListYValues="@listShearStresses" ListUseMarkers="@listUseMarkers" ListNames="@listNames"
                         XAxisTitle="Shear rate" YAxisTitle="Shear stress" @ref="flowCurvePlot" />
                </div>

            </div>
        }
    }
</UnitAndReferenceChoiceTag>

@code {
    // html booleans for dynamic visualization
    private bool IsHidMainPanel = false;
    private bool IsHidSubPanel = true;
    private bool IsHidInputPanel = true;
    private bool IsHidInputAdd = false;
    private bool IsHidCalcPanel = true;

    // model data objects
    private List<YPLCorrection> yplCorrectionList;
    private List<Rheogram> inputRheogramList;

    // UI binding variables
    private string addedYplCorrectionName = null;
    private string addedYplCorrectionDescr = null;
    private string updatedYplCorrectionName = null;
    private string updatedYplCorrectionDescr = null;

    // variables identifying user's selected objects
    private int yplCorrectionIdx = -1; // the index of the selected YPLCorrection
    private Guid yplCorrectionID = Guid.Empty;
    private Guid rheogramID = Guid.Empty;
    private int rowIndex = -1; // the index of the row selected in the Input panel

    private ScatterPlot flowCurvePlot = new ScatterPlot();
    private List<object> shearRates = new List<object>();
    private List<object> shearStresses = new List<object>();
    private List<List<object>> listShearRates = new List<List<object>>();
    private List<List<object>> listShearStresses = new List<List<object>>();
    private List<string> listNames = new List<string>();
    private List<bool> listUseMarkers = new List<bool>();

    protected override async Task OnInitializedAsync()
    {
        try
        {
            logger.LogInformation("Trying to load YPLCorrections from client: " + APIUtils.HttpClientYPLCalibrationFromRheometer);
            yplCorrectionList = await APIUtils.LoadDatas<YPLCorrection>(logger, APIUtils.HttpClientYPLCalibrationFromRheometer, "YPLCorrections/");
            if (yplCorrectionList != null)
                yplCorrectionList.Sort((d1, d2) => d1.Name.CompareTo(d2.Name));
            if (yplCorrectionList != null)
            {
                inputRheogramList = await APIUtils.LoadDatas<Rheogram>(logger, APIUtils.HttpClientYPLCalibrationFromRheometer, "Rheograms/");
                if (inputRheogramList != null)
                    inputRheogramList.Sort((d1, d2) => d1.Name.CompareTo(d2.Name));
            }
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Impossible to load YPLCorrections or Rheograms on initialization");
        }
    }

    private void Edit(int idx)
    {
        if (yplCorrectionList != null && idx >= 0 && idx < yplCorrectionList.Count)
        {
            yplCorrectionIdx = idx;
            yplCorrectionID = yplCorrectionList[idx].ID;
            updatedYplCorrectionName = yplCorrectionList[idx].Name;
            updatedYplCorrectionDescr = yplCorrectionList[idx].Description;
            rheogramID = yplCorrectionList[idx].RheogramInput.ID;
            IsHidMainPanel = true;
            IsHidSubPanel = false;
        }
    }

    private async void Delete(int idx)
    {
        if (yplCorrectionList != null && idx >= 0 && idx < yplCorrectionList.Count && yplCorrectionList[idx] != null && !yplCorrectionList[idx].ID.Equals(System.Guid.Empty))
        {
            // delete YPLCorrection from database (output children are implicitly deleted from their database)
            var a = await APIUtils.HttpClientYPLCalibrationFromRheometer.DeleteAsync("YPLCorrections/" + yplCorrectionList[idx].ID);
            if (a.IsSuccessStatusCode)
            {
                await OnInitializedAsync();
                await InvokeAsync(() => { StateHasChanged(); });
            }
            else
            {
                logger.LogWarning("Impossible to delete the selected YPLCorrection");
            }
        }
    }

    private async void Update(int idx)
    {
        if (yplCorrectionList != null && idx >= 0 && idx < yplCorrectionList.Count && !yplCorrectionList[idx].ID.Equals(System.Guid.Empty) && !string.IsNullOrEmpty(updatedYplCorrectionName))
        {
            yplCorrectionList[idx].Name = updatedYplCorrectionName;
            yplCorrectionList[idx].Description = updatedYplCorrectionDescr;

            // PUT YPLCorrection into the YPLCorrectionsTable (calculation is performed and output children database is also updated)
            StringContent content = new StringContent(yplCorrectionList[idx].GetJson(), Encoding.UTF8, "application/json");
            var a = await APIUtils.HttpClientYPLCalibrationFromRheometer.PutAsync("YPLCorrections/" + yplCorrectionList[idx].ID, content);
            if (a.IsSuccessStatusCode)
            {
                updatedYplCorrectionName = null;
                updatedYplCorrectionDescr = null;

                IsHidMainPanel = false;
                IsHidSubPanel = true;
                yplCorrectionIdx = -1;
                rheogramID = Guid.Empty;

                await OnInitializedAsync();
                await InvokeAsync(() => { StateHasChanged(); });
            }
            else
            {
                logger.LogWarning("Impossible to update the current YPLCorrection");
            }
        }
    }

    private void Cancel(int idx)
    {
        if (yplCorrectionList != null && idx >= 0 && idx < yplCorrectionList.Count)
        {
            IsHidMainPanel = false;
            IsHidSubPanel = true;
            yplCorrectionIdx = -1;
        }
    }
    private async Task PlotFlowCurve()
    {
        // update scatter plot
        shearRates.Clear();
        shearStresses.Clear();
        double minShearRate = double.MaxValue;
        double maxShearRate = double.MinValue;
        if (yplCorrectionList != null &&
            yplCorrectionIdx < yplCorrectionList.Count &&
            yplCorrectionList[yplCorrectionIdx] != null &
            yplCorrectionList[yplCorrectionIdx].RheogramInput != null &&
            yplCorrectionList[yplCorrectionIdx].RheogramInput.Measurements != null)
        {
            for (int i = 0; i < yplCorrectionList[yplCorrectionIdx].RheogramInput.Measurements.Count; ++i)
            {
                if (yplCorrectionList[yplCorrectionIdx].RheogramInput.Measurements.ElementAt(i).BobNewtonianShearRate < minShearRate)
                {
                    minShearRate = yplCorrectionList[yplCorrectionIdx].RheogramInput.Measurements.ElementAt(i).BobNewtonianShearRate;
                }
                if (yplCorrectionList[yplCorrectionIdx].RheogramInput.Measurements.ElementAt(i).BobNewtonianShearRate > maxShearRate)
                {
                    maxShearRate = yplCorrectionList[yplCorrectionIdx].RheogramInput.Measurements.ElementAt(i).BobNewtonianShearRate;
                }
                shearRates.Add(yplCorrectionList[yplCorrectionIdx].RheogramInput.Measurements.ElementAt(i).BobNewtonianShearRate);
                shearStresses.Add(yplCorrectionList[yplCorrectionIdx].RheogramInput.Measurements.ElementAt(i).BobNewtonianShearStress);
            }
        }
        listShearRates.Clear();
        listShearStresses.Clear();
        listNames.Clear();
        listUseMarkers.Clear();
        int count = 50;
        if (yplCorrectionList != null &&
            yplCorrectionIdx < yplCorrectionList.Count &&
            yplCorrectionList[yplCorrectionIdx] != null &
            yplCorrectionList[yplCorrectionIdx].YPLModelBasedOnNewtonianInputs != null &&
            minShearRate < maxShearRate)
        {
            List<object> srs = new List<object>();
            List<object> sss = new List<object>();
            double step = (maxShearRate - minShearRate) / (count - 1);
            YPLModel model = yplCorrectionList[yplCorrectionIdx].YPLModelBasedOnNewtonianInputs;
            for (int i = 0; i < count; i++)
            {
                double shearRate = minShearRate + i * step;
                srs.Add(shearRate);
                sss.Add(model.Tau0 + model.K * Math.Pow(shearRate, model.N));
            }
            listShearRates.Add(srs);
            listShearStresses.Add(sss);
            listNames.Add("YPL From Newtonian Assumption");
            listUseMarkers.Add(false);
        }
        minShearRate = double.MaxValue;
        maxShearRate = double.MinValue;
        if (yplCorrectionList != null &&
            yplCorrectionIdx < yplCorrectionList.Count &&
            yplCorrectionList[yplCorrectionIdx] != null &
            yplCorrectionList[yplCorrectionIdx].RheogramFullyCorrected != null)
        {
            List<object> srs = new List<object>();
            List<object> sss = new List<object>();
            for (int i = 0; i < yplCorrectionList[yplCorrectionIdx].RheogramFullyCorrected.Count; ++i)
            {
                if (yplCorrectionList[yplCorrectionIdx].RheogramFullyCorrected.ElementAt(i).ShearRate < minShearRate)
                {
                    minShearRate = yplCorrectionList[yplCorrectionIdx].RheogramFullyCorrected.ElementAt(i).ShearRate;
                }
                if (yplCorrectionList[yplCorrectionIdx].RheogramFullyCorrected.ElementAt(i).ShearRate > maxShearRate)
                {
                    maxShearRate = yplCorrectionList[yplCorrectionIdx].RheogramFullyCorrected.ElementAt(i).ShearRate;
                }
                srs.Add(yplCorrectionList[yplCorrectionIdx].RheogramFullyCorrected.ElementAt(i).ShearRate);
                sss.Add(yplCorrectionList[yplCorrectionIdx].RheogramFullyCorrected.ElementAt(i).ShearStress);
            }
            listShearRates.Add(srs);
            listShearStresses.Add(sss);
            listNames.Add("Fully Corrected Rheogram");
            listUseMarkers.Add(true);
        }
        if (yplCorrectionList != null &&
            yplCorrectionIdx < yplCorrectionList.Count &&
            yplCorrectionList[yplCorrectionIdx] != null &
            yplCorrectionList[yplCorrectionIdx].YPLModelFullyCorrected != null &&
            minShearRate < maxShearRate)
        {
            List<object> srs = new List<object>();
            List<object> sss = new List<object>();
            double step = (maxShearRate - minShearRate) / (count - 1);
            YPLModel model = yplCorrectionList[yplCorrectionIdx].YPLModelFullyCorrected;
            for (int i = 0; i < count; i++)
            {
                double shearRate = minShearRate + i * step;
                srs.Add(shearRate);
                sss.Add(model.Tau0 + model.K * Math.Pow(shearRate, model.N));
            }
            listShearRates.Add(srs);
            listShearStresses.Add(sss);
            listNames.Add("YPL From Fully Corrected Rheogram");
            listUseMarkers.Add(false);
        }
        minShearRate = double.MaxValue;
        maxShearRate = double.MinValue;
        if (yplCorrectionList != null &&
            yplCorrectionIdx < yplCorrectionList.Count &&
            yplCorrectionList[yplCorrectionIdx] != null &
            yplCorrectionList[yplCorrectionIdx].RheogramShearRateCorrected != null)
        {
            List<object> srs = new List<object>();
            List<object> sss = new List<object>();
            for (int i = 0; i < yplCorrectionList[yplCorrectionIdx].RheogramShearRateCorrected.Count; ++i)
            {
                if (yplCorrectionList[yplCorrectionIdx].RheogramShearRateCorrected.ElementAt(i).ShearRate < minShearRate)
                {
                    minShearRate = yplCorrectionList[yplCorrectionIdx].RheogramShearRateCorrected.ElementAt(i).ShearRate;
                }
                if (yplCorrectionList[yplCorrectionIdx].RheogramShearRateCorrected.ElementAt(i).ShearRate > maxShearRate)
                {
                    maxShearRate = yplCorrectionList[yplCorrectionIdx].RheogramShearRateCorrected.ElementAt(i).ShearRate;
                }
                srs.Add(yplCorrectionList[yplCorrectionIdx].RheogramShearRateCorrected.ElementAt(i).ShearRate);
                sss.Add(yplCorrectionList[yplCorrectionIdx].RheogramShearRateCorrected.ElementAt(i).ShearStress);
            }
            listShearRates.Add(srs);
            listShearStresses.Add(sss);
            listNames.Add("Shear-rate Corrected Rheogram");
            listUseMarkers.Add(true);
        }
        if (yplCorrectionList != null &&
            yplCorrectionIdx < yplCorrectionList.Count &&
            yplCorrectionList[yplCorrectionIdx] != null &
            yplCorrectionList[yplCorrectionIdx].YPLModelShearRateCorrected != null &&
            minShearRate < maxShearRate)
        {
            List<object> srs = new List<object>();
            List<object> sss = new List<object>();
            double step = (maxShearRate - minShearRate) / (count - 1);
            YPLModel model = yplCorrectionList[yplCorrectionIdx].YPLModelShearRateCorrected;
            for (int i = 0; i < count; i++)
            {
                double shearRate = minShearRate + i * step;
                srs.Add(shearRate);
                sss.Add(model.Tau0 + model.K * Math.Pow(shearRate, model.N));
            }
            listShearRates.Add(srs);
            listShearStresses.Add(sss);
            listNames.Add("YPL From Shear-rate Corrected Rheogram");
            listUseMarkers.Add(false);
        }
        minShearRate = double.MaxValue;
        maxShearRate = double.MinValue;
        if (yplCorrectionList != null &&
            yplCorrectionIdx < yplCorrectionList.Count &&
            yplCorrectionList[yplCorrectionIdx] != null &
            yplCorrectionList[yplCorrectionIdx].RheogramShearStressCorrected != null)
        {
            List<object> srs = new List<object>();
            List<object> sss = new List<object>();
            for (int i = 0; i < yplCorrectionList[yplCorrectionIdx].RheogramShearStressCorrected.Count; ++i)
            {
                if (yplCorrectionList[yplCorrectionIdx].RheogramShearStressCorrected.ElementAt(i).ShearRate < minShearRate)
                {
                    minShearRate = yplCorrectionList[yplCorrectionIdx].RheogramShearStressCorrected.ElementAt(i).ShearRate;
                }
                if (yplCorrectionList[yplCorrectionIdx].RheogramShearStressCorrected.ElementAt(i).ShearRate > maxShearRate)
                {
                    maxShearRate = yplCorrectionList[yplCorrectionIdx].RheogramShearStressCorrected.ElementAt(i).ShearRate;
                }
                srs.Add(yplCorrectionList[yplCorrectionIdx].RheogramShearStressCorrected.ElementAt(i).ShearRate);
                sss.Add(yplCorrectionList[yplCorrectionIdx].RheogramShearStressCorrected.ElementAt(i).ShearStress);
            }
            listShearRates.Add(srs);
            listShearStresses.Add(sss);
            listNames.Add("Shear-stress Corrected Rheogram");
            listUseMarkers.Add(true);
        }
        if (yplCorrectionList != null &&
            yplCorrectionIdx < yplCorrectionList.Count &&
            yplCorrectionList[yplCorrectionIdx] != null &
            yplCorrectionList[yplCorrectionIdx].YPLModelShearStressCorrected != null &&
            minShearRate < maxShearRate)
        {
            List<object> srs = new List<object>();
            List<object> sss = new List<object>();
            double step = (maxShearRate - minShearRate) / (count - 1);
            YPLModel model = yplCorrectionList[yplCorrectionIdx].YPLModelShearStressCorrected;
            for (int i = 0; i < count; i++)
            {
                double shearRate = minShearRate + i * step;
                srs.Add(shearRate);
                sss.Add(model.Tau0 + model.K * Math.Pow(shearRate, model.N));
            }
            listShearRates.Add(srs);
            listShearStresses.Add(sss);
            listNames.Add("YPL From Shear-stress Corrected Rheogram");
            listUseMarkers.Add(false);
        }

        try
        {
            await flowCurvePlot.Plot();
        }
        catch (Exception ex)
        {
            logger.LogWarning(ex.Message, "Plot has been disposed");
        }
    }

    private async void Add()
    {
        if (!string.IsNullOrEmpty(addedYplCorrectionName) && inputRheogramList != null && inputRheogramList.Count > 0)
        {
            YPLCorrection addedYplCorrection = new YPLCorrection();
            addedYplCorrection.ID = Guid.NewGuid();
            addedYplCorrection.Name = addedYplCorrectionName;
            addedYplCorrection.Description = addedYplCorrectionDescr;
            addedYplCorrection.RheogramInput = inputRheogramList[0]; // by default, the first available Rheogram is used as input
            addedYplCorrection.RheogramFullyCorrected = new List<ShearRateAndStress>();
            addedYplCorrection.RheogramShearRateCorrected = new List<ShearRateAndStress>();
            addedYplCorrection.RheogramShearStressCorrected = new List<ShearRateAndStress>();

            // POST the YPLCorrection (note that it adds RheogramInput to the input database, triggers the CalculateOutputRheogram() method and adds the corresponding output to the output database)
            StringContent content = new StringContent(addedYplCorrection.GetJson(), Encoding.UTF8, "application/json");
            var a = await APIUtils.HttpClientYPLCalibrationFromRheometer.PostAsync("YPLCorrections", content);
            if (a.IsSuccessStatusCode)
            {
                addedYplCorrectionName = null;
                addedYplCorrectionDescr = null;

                await OnInitializedAsync();
                await InvokeAsync(() => { StateHasChanged(); });
            }
            else
            {
                logger.LogWarning("Impossible to add the current YPLCorrection");
            }
        }
    }

    private void Cancel()
    {
        // empty UI edit box
        addedYplCorrectionName = null;
        addedYplCorrectionDescr = null;
    }

    private async void UpdateInput()
    {
        try
        {
            // first GET the selected Rheogram
            Rheogram rheogram = null;
            var a = await APIUtils.HttpClientYPLCalibrationFromRheometer.GetAsync("Rheograms/" + rheogramID.ToString());
            if (a.IsSuccessStatusCode && a.Content != null)
            {
                string str = await a.Content.ReadAsStringAsync();
                if (!string.IsNullOrEmpty(str))
                {
                    rheogram = JsonConvert.DeserializeObject<Rheogram>(str);
                    if (rheogram == null)
                        throw new NullReferenceException("Impossible to deserialize Rheogram string:" + str);
                    yplCorrectionList[yplCorrectionIdx].RheogramInput = rheogram;

                    // then PUT the YPLCorrection with an updated RheogramInput value
                    StringContent content = new StringContent(yplCorrectionList[yplCorrectionIdx].GetJson(), Encoding.UTF8, "application/json");
                    a = await APIUtils.HttpClientYPLCalibrationFromRheometer.PutAsync("YPLCorrections/" + yplCorrectionID.ToString(), content);
                    if (a.IsSuccessStatusCode)
                    {
                        await OnInitializedAsync();
                        await InvokeAsync(() => { StateHasChanged(); });
                    }
                    else
                    {
                        logger.LogWarning("Impossible to update the current YPLCorrection");
                    }
                }
            }
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Impossible to update the current YPLCorrection");
        }
    }

    private void HideInput()
    {
        IsHidInputPanel = !IsHidInputPanel;
    }

    private async Task HideCalc()
    {
        IsHidCalcPanel = !IsHidCalcPanel;
        if (yplCorrectionIdx >= 0)
            await PlotFlowCurve();
    }
}


