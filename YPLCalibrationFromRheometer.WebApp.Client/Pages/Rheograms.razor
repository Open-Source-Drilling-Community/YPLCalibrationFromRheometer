@page "/Rheograms"
@inject ILogger<Rheograms> logger

<UnitAndReferenceChoiceTag HttpHost="@YPLCalibrationFromRheometer.WebApp.Client.Configuration.YPLCalibrationHostURL"
                           HttpBasePath="YPLCalibrationFromRheometer/api/"
                           HttpController="DrillingUnitChoiceSets">
    <h1>Rheograms</h1>
    <p>Warning, any change made to the Rheogram's listed below may affect YPLCalibrations which refer to it</p>
    <div hidden="@IsHidSubPanel">
        <div>
            <table class="table">
                <thead>
                    <tr>
                        <td>Name</td>
                        <td>Description</td>
                        <td></td>
                    </tr>
                </thead>
                <tbody>
                    @if (IsHidInputAdd)
                    {
                        <tr>
                            <td>
                                <span class="label">@(rheograms[rheogramIdx].Name)</span>
                            </td>
                            <td>
                                <span class="label">@(rheograms[rheogramIdx].Description)</span>
                            </td>
                            <td></td>
                        </tr>
                    }
                    else
                    {
                        <tr>
                            <td>
                                <input class="text" type="text" size="30" @bind="@updatedRheogramName" />
                            </td>
                            <td>
                                <input class="text" type="text" size="30" @bind="@updatedRheogramDescr" />
                            </td>
                            <td align="right">
                                <button class="btn btn-primary" @onclick="@(() => UpdateWithoutClosing(rheogramIdx))">Update</button>
                                <button class="btn btn-primary" @onclick="@(() => Update(rheogramIdx))">Close</button>
                                <button class="btn btn-primary" @onclick="@(() => Cancel(rheogramIdx))">Cancel</button>
                            </td>
                        </tr>
                    }
                </tbody>
                <tfoot>
                </tfoot>
            </table>
        </div>
    </div>

    @if (rheograms == null)
    {
        <p><em>Loading...</em></p>
    }
    else
    {
        <div hidden="@IsHidMainPanel">
            <table class="table">
                <thead>
                    <tr>
                        <td>Name</td>
                        <td>Description</td>
                        <td></td>
                    </tr>
                </thead>
                <tbody>
                    @for (int i = 0; i < rheograms.Count; i++)
                    {
                        var local_i = i; // Do not use a loop variable directly in a lambda expression
                        <tr>
                            <td>
                                <span class="label">@rheograms[i].Name</span>
                            </td>
                            <td>
                                <span class="label">@(rheograms[i].Description)</span>
                            </td>
                            <td align="right">
                                <button class="btn btn-primary" @onclick="@(() => Edit(local_i))">Edit</button>
                                <button class="btn btn-primary" @onclick="@(() => Delete(local_i))">Delete</button>
                            </td>
                        </tr>
                    }
                </tbody>
                <tfoot>
                    <tr>
                        <td>
                            <input class="text" type="text" size="30" @bind="@addedRheogramName" />
                        </td>
                        <td>
                            <input class="text" type="text" size="30" @bind="@addedRheogramDescr" />
                        </td>
                        <td align="right">
                            <button class="btn btn-primary" @onclick="@(() => Add())">Add</button>
                            <button class="btn btn-primary" @onclick="@(() => Cancel())">Cancel</button>
                        </td>
                    </tr>
                </tfoot>
            </table>

            <p>Below, you can add rheograms from an input csv/xls/xlsx file</p>
            <p>The parser looks into the file, for one or several tables with two consecutive columns labelled "shear rate" and "shear stress", containing at least 3 records, and assuming that values are relative to the value at the bob</p>
            <table class="table">
                <thead>
                    <tr>
                        <td>Name</td>
                        <td>Description</td>
                        <td></td>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>
                            <input class="text" type="text" size="30" @bind="@loadedFileName" />
                        </td>
                        <td>
                            <input class="text" type="text" size="30" @bind="@loadedFileDescr" />
                        </td>
                        <td align="right">
                            @*It is very important that the InputFile component continues to be rendered all the time it takes to download content, otherwise raising BlazorServer.js exceptions*@
                            <label class="btn btn-primary">
                                <InputFile OnChange="@Load" multiple />
                                Load
                            </label>
                            @if (isLoading)
                            {
                                <p>Uploading... @string.Format("{0:P0}", progressPercent)</p>
                            }
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        @if (rheogramIdx >= 0)
        {
            int inputIterData1Count = rheograms[rheogramIdx].Measurements.Count;
            <div hidden="@IsHidSubPanel">
                <div>
                    <button class="btn btn-link" @onclick="@(() => HideInput())"><h2>Rheogram settings</h2></button>
                    <div hidden="@IsHidInputPanel">
                        <div>
                            <h3>Rheometer</h3>
                            <table class="table" style="width: 50%">
                                <tbody>
                                    <tr>
                                        <td style="text-align: left">
                                            <span>Rheometer type</span>
                                        </td>
                                        <td style="text-align: right">
                                            <select @bind="@rheograms[rheogramIdx].CouetteRheometerID">
                                                @foreach (var v in rheometers)
                                                {
                                                    <option value="@v.ID">@v.Name</option>
                                                }
                                            </select>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div>
                            <h3>Rheometer Measurements Input Type</h3>
                            <table class="table" style="width: 50%">
                                <tbody>
                                    <tr hidden="@IsFixedSpeedRheometer">
                                        <td style="text-align: left">
                                            <span>Source for rotation or shear rate</span>
                                        </td>
                                        <td style="text-align: right">
                                            <select @bind="@rheograms[rheogramIdx].RateSource">
                                                @foreach (var v in rateSourceList)
                                                {
                                                    <option value="@v.Item2">@v.Item1</option>
                                                }
                                            </select>
                                        </td>
                                    </tr>
                                    <tr>
                                        <td style="text-align: left">
                                            <span>Source for torque and shear stress</span>
                                        </td>
                                        <td style="text-align: right">
                                            <select @bind="@rheograms[rheogramIdx].StressSource">
                                                @foreach (var v in stressSourceList)
                                                {
                                                    <option value="@v.Item2">@v.Item1</option>
                                                }
                                            </select>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div>
                            <h3>Corrections</h3>
                            <table class="table" style="width: 50%">
                                <tbody>
                                    <tr>
                                        <td style="text-align: left">
                                            <span>Shear rate correction</span>
                                        </td>
                                        <td style="text-align: right">
                                            <select @bind="@rheograms[rheogramIdx].ShearRateCorrection">
                                                @foreach (var v in shearRateCorrectionList)
                                                {
                                                    <option value="@v.Item2">@v.Item1</option>
                                                }
                                            </select>
                                        </td>
                                    </tr>
                                    <tr>
                                        <td style="text-align: left">
                                            <span>Shear stress correction</span>
                                        </td>
                                        <td style="text-align: right">
                                            <select @bind="@rheograms[rheogramIdx].ShearStressCorrection">
                                                @foreach (var v in shearStressCorrectionList)
                                                {
                                                    <option value="@v.Item2">@v.Item1</option>
                                                }
                                            </select>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div>
                            <h3>YPL Calibration</h3>
                            <table class="table" style="width: 50%">
                                <tbody>
                                    <tr>
                                        <td style="text-align: left">
                                            <span>Calibration Method</span>
                                        </td>
                                        <td style="text-align: right">
                                            <select @bind="@rheograms[rheogramIdx].CalibrationMethod">
                                                @foreach (var v in calibrationMethodList)
                                                {
                                                    <option value="@v.Item2">@v.Item1</option>
                                                }
                                            </select>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                    <button class="btn btn-link" @onclick="@(() => HideMeasurements())"><h2>Rheometer measurements</h2></button>
                    <div hidden="@IsHidMeasPanel">
                        <InputRheogram HTTPClient="@APIUtils.HttpClientYPLCalibrationFromRheometer"
                               IsHidden="@IsHidInputAdd"
                               Rheogram="@rheograms[rheogramIdx]"
                               RheogramID="@rheogramID"
                               IsFixedSpeed="@IsFixedSpeedRheometer" />
                    </div>
                    <button class="btn btn-link" @onclick="@(() => HideCalc())"><h2>Correction/Calibration results</h2></button>
                    <div hidden="@IsHidCalcPanel">
                        <h3>Corrected Flow-curve</h3>
                        @if (rheograms[rheogramIdx].CorrectedFlowCurve != null)
                        {
                            <DisplayRheogram ShearRateAndStresses="@rheograms[rheogramIdx].CorrectedFlowCurve" />
                        }
                        <h3>Yield Power Law Model</h3>
                        @if (rheograms[rheogramIdx].CalibratedYPLModel != null)
                        {
                            <YPLCalibrationTable YPLModel="@rheograms[rheogramIdx].CalibratedYPLModel" />
                        }
                    </div>
                    <button class="btn btn-link" @onclick="@(() => HidePlot())"><h2>Plot rheogram</h2></button>
                    <div hidden="@IsHidPlotPanel">
                        <div>
                            <ScatterPlot XQuantityName="FluidShearRate" YQuantityName="FluidShearStress"
                                 ListXValues="@xValues" ListYValues="@yValues" ListUseMarkers="@markers" ListNames="@names"
                                 XAxisTitle="Shear rate" YAxisTitle="Shear stress" @ref="flowCurvePlot" />
                        </div>
                    </div>
                </div>
            </div>
        }
    }
</UnitAndReferenceChoiceTag>

@code {
    // default values
    private string[] SRLabels = { "shearrate", "shear rate" };
    private string[] SSLabels = { "shearstress", "shear stress" };

    private bool IsHidMainPanel = false;
    private bool IsHidSubPanel = true;
    private bool IsHidInputPanel = true;
    private bool IsHidInputAdd = false;
    private bool IsHidCalcPanel = true;
    private bool IsHidMeasPanel = true;
    private bool IsHidPlotPanel = true;
    private bool IsFixedSpeedRheometer = false;

    // main data object
    private List<Rheogram> rheograms = new List<Rheogram>();
    private List<CouetteRheometer> rheometers = new List<CouetteRheometer>();
    private CouetteRheometer rheometer = null;

    private List<Tuple<string, RateSourceEnum>> rateSourceList = new List<Tuple<string, RateSourceEnum>>();
    private List<Tuple<string, StressSourceEnum>> stressSourceList = new List<Tuple<string, StressSourceEnum>>();
    private List<Tuple<string, ShearRateCorrectionEnum>> shearRateCorrectionList = new List<Tuple<string, ShearRateCorrectionEnum>>();
    private List<Tuple<string, ShearStressCorrectionEnum>> shearStressCorrectionList = new List<Tuple<string, ShearStressCorrectionEnum>>();
    private List<Tuple<string, CalibrationMethodEnum>> calibrationMethodList = new List<Tuple<string, CalibrationMethodEnum>>();

    // temporary objects are used essentially to post or put modifications to the database
    private string addedRheogramName = null;
    private string addedRheogramDescr = null;

    private string updatedRheogramName = null;
    private string updatedRheogramDescr = null;

    private string loadedFileName = null;
    private string loadedFileDescr = null;

    private bool isLoading;
    private decimal progressPercent;



    // objects used for visualization
    ScatterPlot flowCurvePlot = new ScatterPlot();
    List<object> newtonianShearRates = new List<object>();
    List<object> newtonianShearStresses = new List<object>();
    List<object> correctedShearRates = new List<object>();
    List<object> correctedShearStresses = new List<object>();
    List<object> YPLModelShearRates = new List<object>();
    List<object> YPLModelShearStresses = new List<object>();
    List<List<object>> xValues = new List<List<object>>();
    List<List<object>> yValues = new List<List<object>>();
    List<bool> markers = new List<bool>();
    List<string> names = new List<string>();

    private int rheogramIdx = -1;
    private Guid rheogramID = Guid.Empty;

    private readonly object lock_ = new object();

    protected override async Task OnInitializedAsync()
    {
        try
        {
            xValues.Clear();
            yValues.Clear();
            markers.Clear();
            names.Clear();
            xValues.Add(newtonianShearRates);
            xValues.Add(correctedShearRates);
            xValues.Add(YPLModelShearRates);
            yValues.Add(newtonianShearStresses);
            yValues.Add(correctedShearStresses);
            yValues.Add(YPLModelShearStresses);
            markers.Add(true);
            markers.Add(true);
            markers.Add(false);
            names.Add("Newtonian Flow-curve");
            names.Add("Corrected Flow-curve");
            names.Add("Calibrated YPL Model");

            rateSourceList.Clear();
            rateSourceList.Add(new Tuple<string, RateSourceEnum>("Rotational Speed", RateSourceEnum.RotationalSpeed));
            rateSourceList.Add(new Tuple<string, RateSourceEnum>("ISO Newtonian Shear Rate", RateSourceEnum.ISONewtonianShearRate));
            rateSourceList.Add(new Tuple<string, RateSourceEnum>("Bob Newtonian Shear Rate", RateSourceEnum.BobNewtonianShearRate));
            stressSourceList.Clear();
            stressSourceList.Add(new Tuple<string, StressSourceEnum>("Torque", StressSourceEnum.Torque));
            stressSourceList.Add(new Tuple<string, StressSourceEnum>("ISO Newtonian Shear Stress", StressSourceEnum.ISONewtonianShearStress));
            stressSourceList.Add(new Tuple<string, StressSourceEnum>("Bob Newtonian Shear Stress", StressSourceEnum.BobNewtonianShearStress));

            shearRateCorrectionList.Clear();
            shearRateCorrectionList.Add(new Tuple<string, ShearRateCorrectionEnum>("Skadsem & Saasen", ShearRateCorrectionEnum.SkadsemSaasen));
            shearRateCorrectionList.Add(new Tuple<string, ShearRateCorrectionEnum>("None", ShearRateCorrectionEnum.None));
            shearStressCorrectionList.Clear();
            shearStressCorrectionList.Add(new Tuple<string, ShearStressCorrectionEnum>("Lac & Parry", ShearStressCorrectionEnum.LacParry));
            shearStressCorrectionList.Add(new Tuple<string, ShearStressCorrectionEnum>("None", ShearStressCorrectionEnum.None));
            calibrationMethodList.Clear();
            calibrationMethodList.Add(new Tuple<string, CalibrationMethodEnum>("Mullineux", CalibrationMethodEnum.Mullineux));
            calibrationMethodList.Add(new Tuple<string, CalibrationMethodEnum>("Levenberg-Marquardt", CalibrationMethodEnum.LevenbergMarquardt));
            calibrationMethodList.Add(new Tuple<string, CalibrationMethodEnum>("Kelessidis", CalibrationMethodEnum.Kelessidis));

            logger.LogInformation("Trying to load Rheograms from client: " + APIUtils.HttpClientYPLCalibrationFromRheometer.ToString());
            rheometers = await APIUtils.LoadDatas<CouetteRheometer>(logger, APIUtils.HttpClientYPLCalibrationFromRheometer, "CouetteRheometers/");

            if (rheometers != null)
                rheometers.Sort((d1, d2) => d1.Name.CompareTo(d2.Name));

            // In case this method is called while handling a particular rheogram, one must store its ID before the list of rheograms is reloaded and sorted differently (in case its name has changed)
            Guid rheoId = Guid.Empty;
            if (rheogramIdx >= 0)
                rheoId = rheograms[rheogramIdx].ID;
            rheograms = await APIUtils.LoadDatas<Rheogram>(logger, APIUtils.HttpClientYPLCalibrationFromRheometer, "Rheograms/");
            if (rheograms != null)
            {
                rheograms.Sort((d1, d2) => d1.Name.CompareTo(d2.Name));
                if (rheoId != Guid.Empty)
                    rheogramIdx = rheograms.FindIndex(r => r.ID.Equals(rheoId));
            }

            if (rheogramIdx >= 0)
                PlotFlowCurve();
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Impossible to load Rheograms on initialization");
        }
    }

    private async void Edit(int idx)
    {
        if (rheograms != null && idx >= 0 && idx < rheograms.Count)
        {
            rheogramIdx = idx;
            updatedRheogramName = rheograms[idx].Name;
            updatedRheogramDescr = rheograms[idx].Description;
            rheogramID = rheograms[idx].ID;
            IsHidMainPanel = true;
            IsHidSubPanel = false;
            // retrieve the rheometer associated with the edited rheogram
            rheometer = rheometers.Find(r => r.ID.Equals(rheograms[idx].CouetteRheometerID));
            if (rheometer != null && rheometer.FixedSpeedList != null && rheometer.FixedSpeedList.Count > 0)
            {
                IsFixedSpeedRheometer = true;
            }
            await OnInitializedAsync();
            await InvokeAsync(() => { StateHasChanged(); });
        }
    }

    private async void Delete(int idx)
    {
        if (rheograms != null && idx >= 0 && idx < rheograms.Count && rheograms[idx] != null && !rheograms[idx].ID.Equals(System.Guid.Empty))
        {
            // delete Rheogram from database
            var a = await APIUtils.HttpClientYPLCalibrationFromRheometer.DeleteAsync("Rheograms/" + rheograms[idx].ID);
            if (a.IsSuccessStatusCode)
            {
                await OnInitializedAsync();
                await InvokeAsync(() => { StateHasChanged(); });
            }
            else
            {
                logger.LogWarning("Impossible to delete the selected Rheograms");
            }
        }
    }

    private async void Update(int idx)
    {
        if (rheograms != null && idx >= 0 && idx < rheograms.Count && !rheograms[idx].ID.Equals(System.Guid.Empty) &&
            !string.IsNullOrEmpty(updatedRheogramName))
        {
            rheograms[idx].Name = updatedRheogramName;
            rheograms[idx].Description = updatedRheogramDescr;

            // automatically set rotation frequencies if the selected rheometer has a fixed list of them
            rheometer = rheometers.Find(r => r.ID.Equals(rheograms[idx].CouetteRheometerID));
            if (rheometer != null && rheometer.FixedSpeedList != null && rheometer.FixedSpeedList.Count > 0)
            {
                UpdateRheogram(rheograms[idx], rheometer);
            }

            //PUT Rheogram into the RheogramInputsTable (YPLCalibrations referencing this Rheogram are updated at the Manager level)
            StringContent content = new StringContent(rheograms[idx].GetJson(), Encoding.UTF8, "application/json");
            var a = await APIUtils.HttpClientYPLCalibrationFromRheometer.PutAsync("Rheograms/" + rheograms[idx].ID, content);
            if (a.IsSuccessStatusCode)
            {
                updatedRheogramName = null;
                updatedRheogramDescr = null;

                IsHidMainPanel = false;
                IsHidSubPanel = true;
                rheogramIdx = -1;
                await OnInitializedAsync();
                await InvokeAsync(() => { StateHasChanged(); });
            }
            else
            {
                logger.LogWarning("Impossible to update the current Rheogram");
            }
        }
    }

    private async void UpdateWithoutClosing(int idx)
    {
        if (rheograms != null && idx >= 0 && idx < rheograms.Count && !rheograms[idx].ID.Equals(System.Guid.Empty) &&
            !string.IsNullOrEmpty(updatedRheogramName))
        {
            rheograms[idx].Name = updatedRheogramName;
            rheograms[idx].Description = updatedRheogramDescr;

            // automatically set rotation frequencies if the selected rheometer has a fixed list of them
            rheometer = rheometers.Find(r => r.ID.Equals(rheograms[idx].CouetteRheometerID));
            if (rheometer != null)
            {
                UpdateRheogram(rheograms[idx], rheometer);
            }

            //PUT Rheogram into the RheogramInputsTable (YPLCalibrations referencing this Rheogram are updated at the Manager level)
            StringContent content = new StringContent(rheograms[idx].GetJson(), Encoding.UTF8, "application/json");
            var a = await APIUtils.HttpClientYPLCalibrationFromRheometer.PutAsync("Rheograms/" + rheograms[idx].ID, content);
            if (a.IsSuccessStatusCode)
            {
                await OnInitializedAsync();
                await InvokeAsync(() => { StateHasChanged(); });
            }
            else
            {
                logger.LogWarning("Impossible to update the current Rheogram");
            }
        }
    }

    private void UpdateRheogram(Rheogram rheogram, CouetteRheometer rheometer)
    {
        bool hasChanged = false;
        IsFixedSpeedRheometer = false;

        if (rheometer.FixedSpeedList != null && rheometer.FixedSpeedList.Count > 0)
        {
            IsFixedSpeedRheometer = true;
            rheogram.RateSource = RateSourceEnum.RotationalSpeed;
        }
        // Rotation speeds are modified to a fixed value and, stress values are reinitialized, if and only if
        // 1- the rheometer has a fixed list of rotation speeds
        // 2- and the number of rotation speeds has changed from before
        // counter-ex: a change from R1B1 8 speeds to R1B2 8 speeds does not change anything (this to avoid retyping everything is misclick)
        // counter-ex: a change from any rheometer to a rheometer with no fixed speeds does not change anything (this to avoid retyping everything is misclick)
        if (IsFixedSpeedRheometer)
        {
            hasChanged = true;
            if (rheogram.Measurements.Count == rheometer.FixedSpeedList.Count)
            {
                bool hasSameValues = true;
                for (int i = 0; i < rheometer.FixedSpeedList.Count; ++i)
                {
                    if (rheogram.Measurements.ElementAt(i).RotationalSpeed != rheometer.FixedSpeedList.ElementAt(i))
                    {
                        hasSameValues = false;
                        break;
                    }
                }
                if (hasSameValues)
                    hasChanged = false;
            }
        }
        if (hasChanged)
        {
            // reinitialize rheometer measurements
            rheogram.Measurements = new List<RheometerMeasurement>();
            if (IsFixedSpeedRheometer)
            {
                foreach (double val in rheometer.FixedSpeedList)
                {
                    RheometerMeasurement meas = new RheometerMeasurement
                        {
                            RotationalSpeed = val
                        };
                    rheogram.Measurements.Add(meas);
                }
            }
            // reinitialize
            rheogram.CorrectedFlowCurve = null;
            rheogram.CalibratedYPLModel = null;
        }
    }

    private void Cancel(int idx)
    {
        if (rheograms != null && idx >= 0 && idx < rheograms.Count)
        {
            IsHidMainPanel = false;
            IsHidSubPanel = true;
            IsFixedSpeedRheometer = false;
            rheogramIdx = -1;
        }
    }

    private async void Add()
    {
        if (!string.IsNullOrEmpty(addedRheogramName) && rheometers.Count > 0)
        {
            Rheogram addedRheogram = new Rheogram();
            addedRheogram.ID = Guid.NewGuid();
            addedRheogram.Name = addedRheogramName;
            addedRheogram.Description = addedRheogramDescr;
            rheometer = rheometers.First();
            addedRheogram.CouetteRheometerID = rheometer.ID;

            // check whether the rheometer has a fixed list of rotational frequency
            if (rheometer.FixedSpeedList != null && rheometer.FixedSpeedList.Count > 0)
            {
                UpdateRheogram(addedRheogram, rheometer);
            }

            // POST the Rheogram
            StringContent content = new StringContent(addedRheogram.GetJson(), Encoding.UTF8, "application/json");
            var a = await APIUtils.HttpClientYPLCalibrationFromRheometer.PostAsync("Rheograms/", content);
            if (a.IsSuccessStatusCode)
            {
                addedRheogramName = null;
                addedRheogramDescr = null;

                await OnInitializedAsync();
                await InvokeAsync(() => { StateHasChanged(); });
            }
            else
            {
                logger.LogWarning("Impossible to add the current Rheogram");
            }
        }
    }

    private async void Load(InputFileChangeEventArgs e)
    {

        isLoading = true;
        progressPercent = 0;
        DataTableCollection dts = null;

        //Uploading files from client navigator
        foreach (var file in e.GetMultipleFiles())
        {
            try
            {
                string tempPath = Path.Combine(Path.GetTempPath(), Path.GetTempFileName());

                await using FileStream writeStream = new(tempPath, FileMode.Create);
                using var readStream = file.OpenReadStream();
                var bytesRead = 0;
                var totalRead = 0;
                var buffer = new byte[1024 * 10];

                while ((bytesRead = await readStream.ReadAsync(buffer)) != 0)
                {
                    totalRead += bytesRead;

                    await writeStream.WriteAsync(buffer, 0, bytesRead);

                    progressPercent = Decimal.Divide(totalRead, file.Size);

                    StateHasChanged();
                }

                using (var reader = ExcelReaderFactory.CreateReader(writeStream))
                {
                    var result = reader.AsDataSet();
                    dts = result.Tables;
                }
            }
            catch (Exception ex)
            {
                logger.LogError(ex, "Impossible to read from file");
            }
        }

        if (dts != null)
        {
            //Loop on tables of uploaded file
            foreach (DataTable table in dts)
            {
                List<List<RheometerMeasurement>> rheoLists = new List<List<RheometerMeasurement>>();
                if (ParseDataTable(table, rheoLists))
                {
                    for (int i = 0; i < rheoLists.Count; ++i)
                    {
                        Rheogram loadedRheogram = new Rheogram();
                        loadedRheogram.ID = Guid.NewGuid();
                        loadedRheogram.Name = String.IsNullOrEmpty(loadedFileName) ? $"{table.TableName}-{i + 1}" : loadedFileName + $"-{table.TableName}-{i + 1}";
                        loadedRheogram.Description = loadedFileDescr;
                        loadedRheogram.Measurements = rheoLists.ElementAt(i);
                        // POST the Rheogram
                        StringContent content = new StringContent(loadedRheogram.GetJson(), Encoding.UTF8, "application/json");
                        var a = await APIUtils.HttpClientYPLCalibrationFromRheometer.PostAsync("Rheograms/", content);
                        if (a.IsSuccessStatusCode)
                        {
                            await OnInitializedAsync();
                            await InvokeAsync(() => { StateHasChanged(); });
                        }
                    }
                }
                else
                {
                    logger.LogInformation($"No parseable data in table {table.TableName}");
                }
            }
        }
        else
        {
            logger.LogError("Impossible to parse loaded file");
        }

        // initializes the UI
        loadedFileName = null;
        loadedFileDescr = null;
        isLoading = false;
        //await OnInitializedAsync();
        //await InvokeAsync(() => { StateHasChanged(); });
        StateHasChanged();
    }

    private bool ParseDataTable(DataTable table, List<List<RheometerMeasurement>> rheoLists)
    {
        //a valid rheogram must consist of a set of:
        //    - 2 columns (containing the labels defined in SRLabels and SSLabels)
        //    - with at least 1 header row (containing the strings "shear rate" and "shear stress")
        //    - at max 2 header rows (second: containing units strings, in any case assumed to be expressed in SI)
        //    - at least 3 double type data rows
        //    - no more than 2 consecutive ShearRateAndStress having the same shear rate (when applying ramp down and up)
        List<int[]> startIndices = new List<int[]>();
        int minMeasCount = 3;
        //first, parse for starting indices within the table that met the first two above conditions
        for (int i = 0; i < table.Rows.Count - (minMeasCount + 1); ++i)
        {
            for (int j = 0; j < table.Columns.Count - 1; ++j)
            {
                if (MatchesLabel(table.Rows[i][j], SRLabels) && MatchesLabel(table.Rows[i][j + 1], SSLabels))
                    startIndices.Add(new int[] { i, j });
            }
        }

        //then, iterate over the different rheograms contained within the current table
        for (int k = 0; k < startIndices.Count; ++k)
        {
            //for each of them, find the indices where numeric values start, depending on whether there is a unit header or not
            List<RheometerMeasurement> rheoList = new List<RheometerMeasurement>();
            int i0 = startIndices.ElementAt(k)[0];
            int j0 = startIndices.ElementAt(k)[1];
            double sr, ss;
            if (double.TryParse(table.Rows[i0 + 1][j0].ToString(), out sr) && double.TryParse(table.Rows[i0 + 1][j0 + 1].ToString(), out ss))
            {
                logger.LogInformation($"No unit header for record starting at row,col {i0},{j0} in table {table.TableName}. SI units assumed");
                i0 += 1;
            }
            else if (double.TryParse(table.Rows[i0 + 2][j0].ToString(), out sr) && double.TryParse(table.Rows[i0 + 2][j0 + 1].ToString(), out ss))
            {
                logger.LogInformation($"A unit header has been found for record starting at row,col {i0},{j0} in table {table.TableName}. Still, SI units assumed");
                i0 += 2;
            }
            else
            {
                logger.LogInformation($"Badly formed record in table {table.TableName} starting at row,col {i0},{j0}");
                continue;
            }
            //finally, store rheometer measurements for the current rheogram
            int i = 0;
            double srPrev = -999.25;
            double srPrevPrev = -998.25;

            while (i < table.Rows.Count - i0 &&
                double.TryParse(table.Rows[i0 + i][j0].ToString(), out sr) &&
                double.TryParse(table.Rows[i0 + i][j0 + 1].ToString(), out ss) &&
                !OSDC.DotnetLibraries.General.Common.Numeric.EQ(sr, srPrev) && !OSDC.DotnetLibraries.General.Common.Numeric.EQ(sr, srPrevPrev))
            {
                RheometerMeasurement meas = new RheometerMeasurement();
                meas.BobNewtonianShearRate = sr;
                meas.BobNewtonianShearStress = ss;
                rheoList.Add(meas);
                i++;
                srPrevPrev = srPrev;
                srPrev = sr;
            }
            logger.LogInformation($"     record's count is {i}");
            if (i >= minMeasCount)
                rheoLists.Add(rheoList); //meeting the last above condition
        }
        return rheoLists.Count > 0;
    }

    private bool MatchesLabel(object value, string[] labels)
    {
        string str = value.ToString().ToLower();
        foreach (string lbl in labels)
        {
            if (str.Contains(lbl))
                return true;
        }
        return false;
    }

    private void Cancel()
    {
        // empty UI edit box
        addedRheogramName = null;
        addedRheogramDescr = null;
        loadedFileName = null;
        loadedFileDescr = null;
    }

    private void HideInput()
    {
        IsHidInputPanel = !IsHidInputPanel;
    }

    private void HideMeasurements()
    {
        IsHidMeasPanel = !IsHidMeasPanel;
    }

    private void HideCalc()
    {
        IsHidCalcPanel = !IsHidCalcPanel;
    }

    private void HidePlot()
    {
        IsHidPlotPanel = !IsHidPlotPanel;
    }

    private async void PlotFlowCurve()
    {
        // update scatter plot
        newtonianShearRates.Clear();
        newtonianShearStresses.Clear();
        for (int i = 0; i < rheograms[rheogramIdx].Measurements.Count; ++i)
        {
            newtonianShearRates.Add(rheograms[rheogramIdx].Measurements.ElementAt(i).BobNewtonianShearRate);
            newtonianShearStresses.Add(rheograms[rheogramIdx].Measurements.ElementAt(i).BobNewtonianShearStress);
        }
        correctedShearRates.Clear();
        correctedShearStresses.Clear();
        double minShearRate = double.MaxValue;
        double maxShearRate = double.MinValue;
        if (rheograms[rheogramIdx].CorrectedFlowCurve != null)
        {
            for (int i = 0; i < rheograms[rheogramIdx].CorrectedFlowCurve.Count; ++i)
            {
                if (rheograms[rheogramIdx].CorrectedFlowCurve.ElementAt(i).ShearRate > maxShearRate)
                {
                    maxShearRate = rheograms[rheogramIdx].CorrectedFlowCurve.ElementAt(i).ShearRate;
                }
                if (rheograms[rheogramIdx].CorrectedFlowCurve.ElementAt(i).ShearRate < minShearRate)
                {
                    minShearRate = rheograms[rheogramIdx].CorrectedFlowCurve.ElementAt(i).ShearRate;
                }
                correctedShearRates.Add(rheograms[rheogramIdx].CorrectedFlowCurve.ElementAt(i).ShearRate);
                correctedShearStresses.Add(rheograms[rheogramIdx].CorrectedFlowCurve.ElementAt(i).ShearStress);
            }
        }
        YPLModelShearRates.Clear();
        YPLModelShearStresses.Clear();
        if (rheograms[rheogramIdx].CalibratedYPLModel != null && minShearRate < maxShearRate)
        {
            YPLModel model = rheograms[rheogramIdx].CalibratedYPLModel;
            double step = (maxShearRate - minShearRate) / 50.0;
            for (double shearRate = minShearRate; OSDC.DotnetLibraries.General.Common.Numeric.LE(shearRate, maxShearRate); shearRate += step)
            {
                YPLModelShearRates.Add(shearRate);
                YPLModelShearStresses.Add(model.Tau0 + model.K * Math.Pow(shearRate, model.N));
            }
        }
        try
        {
            await flowCurvePlot.Plot();
        }
        catch (Exception ex)
        {
            logger.LogWarning(ex.Message, "Plot has been disposed");
        }
    }
}