@page "/Rheograms"
@inject ILogger<Rheograms> logger

<UnitAndReferenceChoiceTag HttpHost="@YPLCalibrationFromRheometer.WebApp.Client.Configuration.YPLCalibrationHostURL"
                           HttpBasePath="YPLCalibrationFromRheometer/api/"
                               HttpController="DrillingUnitChoiceSets">
<h1>Rheograms</h1>
<p>Warning, any change made to the Rheogram's listed below may affect YPLCalibrations which refer to it</p>
<div hidden="@IsHidSubPanel">
    <div>
        <table class="table">
            <thead>
                <tr>
                    <td>Name</td>
                    <td>Description</td>
                    <td>
                        <span>Shear stress standard deviation</span>
                            <SpanUnitLabel QuantityName="FluidShearStress" />
                        </td>
                    <td></td>
                </tr>
            </thead>
            <tbody>
                @if (IsHidInputAdd)
                {
                    <tr>
                        <td>
                            <span class="label">@(rheogramList[rheogramIdx].Name)</span>
                        </td>
                        <td>
                            <span class="label">@(rheogramList[rheogramIdx].Description)</span>
                        </td>
                        <td>
                                <SpanWithUnit QuantityName="FluidShearStress"
                                          SIValue="@(rheogramList[rheogramIdx].ShearStressStandardDeviation)" />
                        </td>
                        <td></td>
                    </tr>
                }
                else
                {
                    <tr>
                        <td>
                            <input class="text" type="text" size="30" @bind="@updatedRheogramName" />
                        </td>
                        <td>
                            <input class="text" type="text" size="30" @bind="@updatedRheogramDescr" />
                        </td>
                        <td>
                                <InputWithUnit QuantityName="FluidShearStress"
                                           SIValueNullable="@updatedRheogramStdStress"
                                           SIValueNullableChanged="@((val) => ManageUpdatedRheogramStdStress(val))" />
                        </td>
                        <td align="right">
                            <button class="btn btn-primary" @onclick="@(() => Update(rheogramIdx))">Update</button>
                            <button class="btn btn-primary" @onclick="@(() => Cancel(rheogramIdx))">Cancel</button>
                        </td>
                    </tr>
                }
            </tbody>
            <tfoot>
            </tfoot>
        </table>
    </div>
</div>

@if (rheogramList == null)
{
    <p><em>Loading...</em></p>
}
else
{
    <div hidden="@IsHidMainPanel">
        <table class="table">
            <thead>
                <tr>
                    <td>Name</td>
                    <td>Description</td>
                        <td>
                            <span>Shear stress standard deviation</span>
                            <SpanUnitLabel QuantityName="FluidShearStress" />
                        </td>
                        <td></td>
                </tr>
            </thead>
            <tbody>
                @for (int i = 0; i < rheogramList.Count; i++)
                {
                    var local_i = i; // Do not use a loop variable directly in a lambda expression
                    <tr>
                        <td>
                            <span class="label">@rheogramList[i].Name</span>
                        </td>
                        <td>
                            <span class="label">@(rheogramList[i].Description)</span>
                        </td>
                        <td>
                                <SpanWithUnit QuantityName="FluidShearStress"
                                      SIValue="@(rheogramList[i].ShearStressStandardDeviation)" />
                        </td>
                        <td align="right">
                            <button class="btn btn-primary" @onclick="@(() => Edit(local_i))">Edit</button>
                            <button class="btn btn-primary" @onclick="@(() => Delete(local_i))">Delete</button>
                        </td>
                    </tr>
                }
            </tbody>
            <tfoot>
                <tr>
                    <td>
                        <input class="text" type="text" size="30" @bind="@addedRheogramName" />
                    </td>
                    <td>
                        <input class="text" type="text" size="30" @bind="@addedRheogramDescr" />
                    </td>
                    <td>
                        <InputWithUnit QuantityName="FluidShearStress"
                                       SIValueNullable="@addedRheogramStdStress" 
                                       SIValueNullableChanged="@((val) => ManageAddedRheogramStdStress(val))" />
                    </td>
                    <td align="right">
                        <button class="btn btn-primary" @onclick="@(() => Add())">Add</button>
                        <button class="btn btn-primary" @onclick="@(() => Cancel())">Cancel</button>
                    </td>
                </tr>
                <tr>
                    <td>
                        <input class="text" type="text" size="30" @bind="@loadedFileName" />
                    </td>
                    <td>
                        <input class="text" type="text" size="30" @bind="@loadedFileDescr" />
                    </td>
                    <td>
                        <InputWithUnit QuantityName="FluidShearStress"
                                       SIValueNullable="@loadedFileStdStress"
                                       SIValueNullableChanged="@((val) => ManageAddedRheogramStdStress(val))" />
                    </td>
                    <td align="right">
                        @*It is very important that the InputFile component continues to be rendered all the time it takes to download content, otherwise raising BlazorServer.js exceptions*@
                        <label class="btn btn-primary">
                            <InputFile OnChange="@Load" multiple />
                            Load
                        </label>
                        @if (isLoading)
                        {
                            <p>Uploading... @string.Format("{0:P0}", progressPercent)</p>
                        }
                    </td>
                </tr>
            </tfoot>
        </table>
    </div>
    @if (rheogramIdx >= 0)
    {
        int inputIterData1Count = rheogramList[rheogramIdx].RheometerMeasurementList.Count;
        <div hidden="@IsHidSubPanel">
            <div>
                 <h2>RheometerMeasurements</h2>
                 <InputRheogram HTTPClient="@httpClient" IsHidden="@IsHidInputAdd" Rheogram="@rheogramList[rheogramIdx]" RheogramID="@rheogramID" />
            </div>
            <div>
                  <ScatterPlot XQuantityName="FluidShearRate" YQuantityName="FluidShearStress" 
                               XValues="@shearRates" YValues="@shearStresses"  UseMarker="true"
                               XAxisTitle="Shear rate" YAxisTitle="Shear stress" @ref="flowCurvePlot" />
            </div>
        </div>
    }
}
</UnitAndReferenceChoiceTag>

@code {
    // default values
    private const double Rheogram_StdShearStress = .01; // this value is the same as in Model.Rheogram (could maybe be shared through ModelClientShared)
    private string[] SRLabels = { "shearrate", "shear rate" };
    private string[] SSLabels = { "shearstress", "shear stress" };

    // http client
    private HttpClient httpClient;

    private bool IsHidMainPanel = false;
    private bool IsHidSubPanel = true;
    private bool IsHidInputPanel = true;
    private bool IsHidInputAdd = false;
    private bool IsHidCalcPanel = true;

    // main data object
    private List<Rheogram> rheogramList;

    // temporary objects are used essentially to post or put modifications to the database
    private string addedRheogramName = null;
    private string addedRheogramDescr = null;
    private double? addedRheogramStdStress = Rheogram_StdShearStress;

    private string updatedRheogramName = null;
    private string updatedRheogramDescr = null;
    private double? updatedRheogramStdStress = Rheogram_StdShearStress;

    private string loadedFileName = null;
    private string loadedFileDescr = null;
    private double? loadedFileStdStress = Rheogram_StdShearStress;

    private bool isLoading;
    private decimal progressPercent;

    // objects used for visualization
    ScatterPlot flowCurvePlot = new ScatterPlot();
    List<object> shearRates = new List<object>();
    List<object> shearStresses = new List<object>();

    private int rheogramIdx = -1;
    private Guid rheogramID = Guid.Empty;

    private readonly object lock_ = new object();

    protected override async Task OnInitializedAsync()
    {
        try
        {
            string host = YPLCalibrationFromRheometer.WebApp.Client.Configuration.YPLCalibrationHostURL;
            logger.LogInformation("Trying to load Rheograms from client: " + host);
            SetHttpClient(host);
            rheogramList = await LoadRheograms();
            if (rheogramIdx >= 0)
                PlotFlowCurve();
        }
        catch (Exception ex)
        {
            httpClient = null;
            logger.LogError(ex, "Impossible to load Rheograms on initialization");
        }
    }

    private void SetHttpClient(string host)
    {
        httpClient = new HttpClient();
        httpClient.BaseAddress = new Uri(host + "YPLCalibrationFromRheometer/api/");
        httpClient.DefaultRequestHeaders.Accept.Clear();
        httpClient.DefaultRequestHeaders.Accept.Add(new System.Net.Http.Headers.MediaTypeWithQualityHeaderValue("application/json"));
    }

    private async Task<List<Rheogram>> LoadRheograms()
    {
        bool success = false;
        try
        {
            var a = await httpClient.GetAsync("Rheograms/");
            if (a.IsSuccessStatusCode)
            {
                Guid[] ids = null;
                string str = await a.Content.ReadAsStringAsync();
                if (!string.IsNullOrEmpty(str))
                {
                    ids = Newtonsoft.Json.JsonConvert.DeserializeObject<Guid[]>(str);
                }
                rheogramList = new List<Rheogram>();
                Rheogram rheogram = null;
                for (int i = 0; i < ids.Length; i++)
                {
                    a = await httpClient.GetAsync("Rheograms/" + ids[i].ToString());
                    if (a.IsSuccessStatusCode && a.Content != null)
                    {
                        str = await a.Content.ReadAsStringAsync();
                        if (!string.IsNullOrEmpty(str))
                        {
                            rheogram = JsonConvert.DeserializeObject<Rheogram>(str);
                            if (rheogram == null)
                                throw new NullReferenceException("Impossible to deserialize Rheograms string:" + str);
                            rheogramList.Add(rheogram);
                        }
                    }
                }
                if (rheogramList.Count != ids.Length)
                    throw new Exception("Inconsistent count of Rheogram-loaded IDs and loaded Rheograms.");
                success = true;
            }
            else
            {
                logger.LogWarning("Impossible to get Rheograms from controller");
            }
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Impossible to load Rheograms");
        }
        if (success)
        {
            rheogramList.Sort((rheo1, rheo2) => rheo1.Name.CompareTo(rheo2.Name));
            logger.LogInformation("Loaded Rheograms successfully");
            return rheogramList;
        }
        else
        {
            logger.LogWarning("Impossible to load Rheograms");
            return null;
        }
    }

    private async void Edit(int idx)
    {
        if (rheogramList != null && idx >= 0 && idx < rheogramList.Count)
        {
            rheogramIdx = idx;
            updatedRheogramName = rheogramList[idx].Name;
            updatedRheogramDescr = rheogramList[idx].Description;
            updatedRheogramStdStress = rheogramList[idx].ShearStressStandardDeviation;
            rheogramID = rheogramList[idx].ID;
            IsHidMainPanel = true;
            IsHidSubPanel = false;

            await OnInitializedAsync();
            await InvokeAsync(() => { StateHasChanged(); });
        }
    }

    private async void Delete(int idx)
    {
        if (rheogramList != null && idx >= 0 && idx < rheogramList.Count && rheogramList[idx] != null && !rheogramList[idx].ID.Equals(System.Guid.Empty))
        {
            // delete Rheogram from database
            var a = await httpClient.DeleteAsync("Rheograms/" + rheogramList[idx].ID);
            if (a.IsSuccessStatusCode)
            {
                await OnInitializedAsync();
                await InvokeAsync(() => { StateHasChanged(); });
            }
            else
            {
                logger.LogWarning("Impossible to delete the selected Rheograms");
            }
        }
    }

    private async void Update(int idx)
    {
        if (rheogramList != null && idx >= 0 && idx < rheogramList.Count && !rheogramList[idx].ID.Equals(System.Guid.Empty) &&
            !string.IsNullOrEmpty(updatedRheogramName) && updatedRheogramStdStress != null && updatedRheogramStdStress > 0.0)
        {
            rheogramList[idx].Name = updatedRheogramName;
            rheogramList[idx].Description = updatedRheogramDescr;
            rheogramList[idx].ShearStressStandardDeviation = (double)updatedRheogramStdStress;

            //PUT Rheogram into the RheogramInputsTable (YPLCalibrations referencing this Rheogram are updated at the Manager level)
            StringContent content = new StringContent(rheogramList[idx].GetJson(), Encoding.UTF8, "application/json");
            var a = await httpClient.PutAsync("Rheograms/" + rheogramList[idx].ID, content);
            if (a.IsSuccessStatusCode)
            {
                updatedRheogramName = null;
                updatedRheogramDescr = null;
                updatedRheogramStdStress = Rheogram_StdShearStress;

                IsHidMainPanel = false;
                IsHidSubPanel = true;
                rheogramIdx = -1;
                await OnInitializedAsync();
                await InvokeAsync(() => { StateHasChanged(); });
            }
            else
            {
                logger.LogWarning("Impossible to update the current Rheogram");
            }
        }
    }

    private void Cancel(int idx)
    {
        if (rheogramList != null && idx >= 0 && idx < rheogramList.Count)
        {
            IsHidMainPanel = false;
            IsHidSubPanel = true;
            rheogramIdx = -1;
        }
    }

    private async void Add()
    {
        if (!string.IsNullOrEmpty(addedRheogramName) && addedRheogramStdStress != null && addedRheogramStdStress > 0.0)
        {
            Rheogram addedRheogram = new Rheogram();
            addedRheogram.ID = Guid.NewGuid();
            addedRheogram.Name = addedRheogramName;
            addedRheogram.Description = addedRheogramDescr;
            addedRheogram.ShearStressStandardDeviation = (double)addedRheogramStdStress;

            // POST the Rheogram
            StringContent content = new StringContent(addedRheogram.GetJson(), Encoding.UTF8, "application/json");
            var a = await httpClient.PostAsync("Rheograms/", content);
            if (a.IsSuccessStatusCode)
            {
                addedRheogramName = null;
                addedRheogramDescr = null;
                addedRheogramStdStress = Rheogram_StdShearStress;

                await OnInitializedAsync();
                await InvokeAsync(() => { StateHasChanged(); });
            }
            else
            {
                logger.LogWarning("Impossible to add the current Rheogram");
            }
        }
    }

    private async void Load(InputFileChangeEventArgs e)
    {
        if (loadedFileStdStress != null && loadedFileStdStress > 0.0)
        {
            isLoading = true;
            progressPercent = 0;
            DataTableCollection dts = null;

            //Uploading files from client navigator
            foreach (var file in e.GetMultipleFiles())
            {
                try
                {
                    string tempPath = Path.Combine(Path.GetTempPath(), Path.GetTempFileName());

                    await using FileStream writeStream = new(tempPath, FileMode.Create);
                    using var readStream = file.OpenReadStream();
                    var bytesRead = 0;
                    var totalRead = 0;
                    var buffer = new byte[1024 * 10];

                    while ((bytesRead = await readStream.ReadAsync(buffer)) != 0)
                    {
                        totalRead += bytesRead;

                        await writeStream.WriteAsync(buffer, 0, bytesRead);

                        progressPercent = Decimal.Divide(totalRead, file.Size);

                        StateHasChanged();
                    }

                    using (var reader = ExcelReaderFactory.CreateReader(writeStream))
                    {
                        var result = reader.AsDataSet();
                        dts = result.Tables;
                    }
                }
                catch (Exception ex)
                {
                    logger.LogError(ex, "Impossible to read from file");
                }
            }

            if (dts != null)
            {
                //Loop on tables of uploaded file
                foreach (DataTable table in dts)
                {
                    List<List<RheometerMeasurement>> rheoLists = new List<List<RheometerMeasurement>>();
                    if (ParseDataTable(table, rheoLists))
                    {
                        for (int i = 0; i < rheoLists.Count; ++i)
                        {
                            Rheogram loadedRheogram = new Rheogram();
                            loadedRheogram.ID = Guid.NewGuid();
                            loadedRheogram.Name = String.IsNullOrEmpty(loadedFileName) ? $"{table.TableName}-{i + 1}" : loadedFileName + $"-{table.TableName}-{i + 1}";
                            loadedRheogram.Description = loadedFileDescr;
                            loadedRheogram.ShearStressStandardDeviation = (double)loadedFileStdStress;
                            loadedRheogram.RheometerMeasurementList = rheoLists.ElementAt(i);
                            // POST the Rheogram
                            StringContent content = new StringContent(loadedRheogram.GetJson(), Encoding.UTF8, "application/json");
                            var a = await httpClient.PostAsync("Rheograms/", content);
                            if (a.IsSuccessStatusCode)
                            {
                                await OnInitializedAsync();
                                await InvokeAsync(() => { StateHasChanged(); });
                            }
                        }
                    }
                    else
                    {
                        logger.LogInformation($"No parseable data in table {table.TableName}");
                    }
                }
            }
            else
            {
                logger.LogError("Impossible to parse loaded file");
            }

            // initializes the UI
            loadedFileName = null;
            loadedFileDescr = null;
            loadedFileStdStress = Rheogram_StdShearStress;
            isLoading = false;
            //await OnInitializedAsync();
            //await InvokeAsync(() => { StateHasChanged(); });
            StateHasChanged();
        }
    }

    private bool ParseDataTable(DataTable table, List<List<RheometerMeasurement>> rheoLists)
    {
        //a valid rheogram must consist of a set of:
        //    - 2 columns (containing the labels defined in SRLabels and SSLabels)
        //    - with at least 1 header row (containing the strings "shear rate" and "shear stress")
        //    - at max 2 header rows (second: containing units strings, in any case assumed to be expressed in SI)
        //    - at least 3 double type data rows
        //    - no more than 2 consecutive RheometerMeasurement having the same shear rate (when applying ramp down and up)
        List<int[]> startIndices = new List<int[]>();
        int minMeasCount = 3;
        //first, parse for starting indices within the table that met the first two above conditions
        for (int i = 0; i < table.Rows.Count - (minMeasCount + 1); ++i)
        {
            for (int j = 0; j < table.Columns.Count - 1; ++j)
            {
                if (MatchesLabel(table.Rows[i][j], SRLabels) && MatchesLabel(table.Rows[i][j + 1], SSLabels))
                    startIndices.Add(new int[] { i, j });
            }
        }

        //then, iterate over the different rheograms contained within the current table
        for (int k = 0; k < startIndices.Count; ++k)
        {
            //for each of them, find the indices where numeric values start, depending on whether there is a unit header or not
            List<RheometerMeasurement> rheoList = new List<RheometerMeasurement>();
            int i0 = startIndices.ElementAt(k)[0];
            int j0 = startIndices.ElementAt(k)[1];
            double sr, ss;
            if (double.TryParse(table.Rows[i0 + 1][j0].ToString(), out sr) && double.TryParse(table.Rows[i0 + 1][j0 + 1].ToString(), out ss))
            {
                logger.LogInformation($"No unit header for record starting at row,col {i0},{j0} in table {table.TableName}. SI units assumed");
                i0 += 1;
            }
            else if (double.TryParse(table.Rows[i0 + 2][j0].ToString(), out sr) && double.TryParse(table.Rows[i0 + 2][j0 + 1].ToString(), out ss))
            {
                logger.LogInformation($"A unit header has been found for record starting at row,col {i0},{j0} in table {table.TableName}. Still, SI units assumed");
                i0 += 2;
            }
            else
            {
                logger.LogInformation($"Badly formed record in table {table.TableName} starting at row,col {i0},{j0}");
                continue;
            }
            //finally, store rheometer measurements for the current rheogram
            int i = 0;
            double srPrev = -999.25;
            double srPrevPrev = -998.25;

            while (i < table.Rows.Count - i0 &&
                double.TryParse(table.Rows[i0 + i][j0].ToString(), out sr) &&
                double.TryParse(table.Rows[i0 + i][j0 + 1].ToString(), out ss) &&
                !OSDC.DotnetLibraries.General.Common.Numeric.EQ(sr, srPrev) && !OSDC.DotnetLibraries.General.Common.Numeric.EQ(sr, srPrevPrev))
            {
                RheometerMeasurement meas = new RheometerMeasurement();
                meas.ShearRate = sr;
                meas.ShearStress = ss;
                rheoList.Add(meas);
                i++;
                srPrevPrev = srPrev;
                srPrev = sr;
            }
            logger.LogInformation($"     record's count is {i}");
            if (i >= minMeasCount)
                rheoLists.Add(rheoList); //meeting the last above condition
        }
        return rheoLists.Count > 0;
    }

    private bool MatchesLabel(object value, string[] labels)
    {
        string str = value.ToString().ToLower();
        foreach (string lbl in labels)
        {
            if (str.Contains(lbl))
                return true;
        }
        return false;
    }

    private void Cancel()
    {
        // empty UI edit box
        addedRheogramName = null;
        addedRheogramDescr = null;
        addedRheogramStdStress = Rheogram_StdShearStress;
        loadedFileName = null;
        loadedFileDescr = null;
        loadedFileStdStress = Rheogram_StdShearStress;
    }

    private void HideInput()
    {
        IsHidInputPanel = !IsHidInputPanel;
    }

    private void HideCalc()
    {
        IsHidCalcPanel = !IsHidCalcPanel;
    }

    private async void PlotFlowCurve()
    {
        // update scatter plot
        shearRates.Clear();
        shearStresses.Clear();
        for (int i = 0; i < rheogramList[rheogramIdx].RheometerMeasurementList.Count; ++i)
        {
            shearRates.Add(rheogramList[rheogramIdx].RheometerMeasurementList.ElementAt(i).ShearRate);
            shearStresses.Add(rheogramList[rheogramIdx].RheometerMeasurementList.ElementAt(i).ShearStress);
        }
        try
        {
            await flowCurvePlot.Plot();
        }
        catch (Exception ex)
        {
            logger.LogWarning(ex.Message, "Plot has been disposed");
        }
    }
    private void ManageUpdatedRheogramStdStress(double? val)
    {
        updatedRheogramStdStress = val;
    }
    private void ManageAddedRheogramStdStress(double? val)
    {
        addedRheogramStdStress = val;
    }
    private void ManageLoadedFileStdStress(double? val)
    {
        loadedFileStdStress = val;
    }

}